欢迎新朋友！
这是一个强调创新、创造、自由、和谐、个性化体验的高版本互通生存服务器

初来乍到？没关系！
群公告里有连接地址和入服教程。
游戏内也有热情的玩家提供帮助。

截至2025年8月16日
服务端为Purpur（Java-1.21.8）
支持加入版本
-Java 1.21.X 和 基岩版1.21.71-1.21.101
有专为基岩版优化的菜单界面等内容
双端互通？不仅如此，群服也可互通，Q群内查询玩家信息，消息互转，我们都可以做到
强大的14代英特尔超频物理机，群组优化，技术流服主qwq

集成各种基础插件和功能插件↓
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
完备的商店系统
· 等价交换商店：常用建材以等价交换形式出售，建筑师的福音！
· 稀有物品系统商店：弥补等价交换只卖建材的不足！
· 箱子商店：促进玩家间交易~
有趣的玩法
· 奇幻地形：资源服使用特殊地形加载器与数据包，各种新奇的结构，会打PVP的猪人？
· 季节系统：只在资源服和家园领域添加季节系统，添加难度与趣味性，并为未来的双端兼容星露谷系统做准备awa
· 神秘道具：粒子装扮、宠物、变形、趣味小道具，我可以不用但不能没有~
· 飞行系统：为建筑师设计的限时飞行系统，你一定会用到！
· 高级附魔：添加一百多种新的高级附魔，平衡性优化，添加玩法！
· 腥红之月：资源服每隔段时间会爆发血月，奖励翻倍的同时怪物也会变强！
便民的辅助功能
· 家园领域：可在零境世界免费领取一块超大的地皮，当做自己的私人仓库？
· 领地系统：生存服可用超低价圈地，保护自己的物品与建筑！
· 锁箱子：不想圈地觉得麻烦？试试看木牌箱子锁！
· 方块日志：被拆家了？物品被偷？可自行查看日志，然后火速找服主
· 连锁挖矿：这太棒了
· 玩家互传，家锚点，等等等等常见的功能
强大的反作弊系统
· Vulcan&Matrix混合反作弊，针对投影打印机等做了优化
· 基岩版使用独立的专用反作弊
· 光线追踪反矿透，等等
▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁
详细教程会完善写入文档网站并植入游戏内。

存档计划
梦始之空（生存服）：
存档永不重置，死亡不掉落，轻红石（禁用区块加载器、刷沙）
残墟神域（资源服）：
不定期重置，死亡不掉落，季节，轻红石（禁用区块加载器、刷沙）
零境（家园世界）：
存档永不重置，死亡不掉落，季节，每位玩家免费领取一块

备份策略
玩家背包和插件数据库每6h自动备份一次，保留4个备份。
每天进行一次全端本地备份。
每月进行一次云端备份。


----------------------------------------------------------------------------------------


root@miragedge:/etc/pve/lxc# blkid
/dev/mapper/pve-root: UUID="68fec9e2-024a-4f0d-b1e3-255a94c1f1e7" BLOCK_SIZE="4096" TYPE="ext4"
/dev/sdb2: UUID="636C-AE0D" BLOCK_SIZE="512" TYPE="vfat" PARTUUID="d7065c43-bb1e-4984-9541-09a637511e49"
/dev/sdb3: UUID="R9ymnZ-4qMa-JDGN-6Jwe-Vqy9-AWOl-L8IuIh" TYPE="LVM2_member" PARTUUID="e6fe6d94-9687-45f4-a545-eb1c26158787"
/dev/mapper/pve-swap: UUID="627299f8-4bbc-47c8-8475-f8b624050818" TYPE="swap"
/dev/sdc2: UUID="d81fc22e-ad26-4d0b-ab8d-ee20908682c8" BLOCK_SIZE="4096" TYPE="ext4" PARTUUID="9d18f0ad-6811-44c1-8cde-82aab8700bcb"
/dev/sdc1: LABEL="M-eM-8M-^LM-fM-^MM-71TBM-eM-^FM-7M-fM-^UM-0M-fM-^MM-.M-eM-$M-^G" BLOCK_SIZE="512" UUID="F00831BE8628B875" TYPE="ntfs" PARTLABEL="Basic data partition" PARTUUID="dc3047cf-c3a2-4150-88b3-72908261a9a7"
/dev/nvme0n1: UUID="22d6ffb2-69b5-4920-b951-6066b11e3fe6" BLOCK_SIZE="4096" TYPE="ext4"
/dev/sdb1: PARTUUID="eb399cb8-493f-4f75-a110-1226f12404b5"
/dev/loop0: UUID="8463a7be-1c63-43ac-8cfc-732d143d73db" BLOCK_SIZE="4096" TYPE="ext4"
/dev/mapper/pve-vm--101--disk--1: PTUUID="6621193c-8bf7-49d0-b4f3-5128452b072a" PTTYPE="gpt"
/dev/nvme1n1: LABEL="Optane-M10-NVMe" UUID="085d496f-f12c-4b53-b4d5-ca69590885d2" BLOCK_SIZE="4096" TYPE="ext4"
/dev/sda1: UUID="3d140d59-a52b-447d-a92c-0f0d969e0161" BLOCK_SIZE="4096" TYPE="ext4" PARTUUID="07bdab69-ca58-4784-b454-0d5fb1b9d1b8"



# 挂载 Optane M10 NVMe (ext4)
UUID=085d496f-f12c-4b53-b4d5-ca69590885d2   /mnt/optane-m10-nvme   ext4   defaults,nofail   0   2

# 挂载 WD SN730 NVMe (ext4)
UUID=22d6ffb2-69b5-4920-b951-6066b11e3fe6   /mnt/wd-sn730-nvme   ext4   defaults,nofail   0   2

# 挂载 ST1000VM HDD (NTFS)
UUID=F00831BE8628B875   /mnt/st1000vm-ntfs   ntfs-3g   defaults,nofail,uid=1000,gid=1000,windows_names   0   0

# 挂载 ST1000VM HDD (ext4)
UUID=d81fc22e-ad26-4d0b-ab8d-ee20908682c8   /mnt/st1000vm-ext4   ext4   defaults,nofail   0   2

# 挂载 ZHITAI SSD (ext4)
UUID=3d140d59-a52b-447d-a92c-0f0d969e0161   /mnt/zhitai-ssd-512g   ext4   defaults,nofail   0   2







/dev/sda1: UUID="63242952-36cf-4466-812a-68c7895ebdda" BLOCK_SIZE="4096" TYPE="ext4" PARTUUID="a8e4e8b4-01"
/dev/sdb1: UUID="499d6e2e-9b9c-4434-aa9b-cd9687eca033" BLOCK_SIZE="4096" TYPE="ext4" PARTUUID="05d49b89-01"
/dev/sdc1: UUID="a198fcc1-c74b-400e-8859-e6a4cac37230" BLOCK_SIZE="4096" TYPE="ext4" PARTUUID="9cbe1ac3-01"

UUID=499d6e2e-9b9c-4434-aa9b-cd9687eca033   /mnt/wd-sn730-nvme   ext4   defaults,nofail   0   2

UUID=a198fcc1-c74b-400e-8859-e6a4cac37230   /mnt/st1000vm-ext4   ext4   defaults,nofail   0   2

UUID=7d0de0a1-9a5d-44bc-8643-cbc96ad3ac8c   /mnt/optane-m10-nvme   ext4   defaults,nofail   0   2

UUID=73353ad8-95bb-4cb5-899a-806459681ef9   /mnt/miragedge   ext4   defaults,nofail   0   2



#!/bin/bash
# ====================================================
# [锐界幻境] 生存服启动脚本 - Docker容器专用版
# 版本: 4.0 | 内存: 25GB | 优化: 长期稳定性
# 适用: Paper 1.21.8 生存服务器
# ====================================================

echo "╔══════════════════════════════════════════════════╗"
echo "║        锐界幻境-生存服启动系统 (Docker版)          ║"
echo "║              内存配置: 25GB                      ║"
echo "║              优化重点: 长期稳定性                 ║"
echo "╚══════════════════════════════════════════════════╝"
sleep 1

# ========== 基础配置区域 ==========
# 请根据实际环境修改以下路径

# Java环境路径（Docker容器内）
export JAVA_HOME="/opt/zulu21"
JAVA_BIN="${JAVA_HOME}/bin/java"
JAR_FILE="[核心]purpur-1.21.8-2497.jar"                    # 核心jar文件名
SERVER_NAME="锐界幻境-生存服"              # 服务器显示名称

# ★★★ 内存配置 - 针对25GB容器内存优化 ★★★
# 容器总内存: 25GB → JVM堆: 22GB + 堆外内存: 3GB
XMS="14G"       # 初始堆大小（避免堆增长停顿）
XMX="15G"       # 最大堆大小（预留堆外内存空间）
SOFT_MAX_HEAP="14G"  # ZGC软最大堆（内存压力目标）

# ★★★ GC配置 - 生存服优化参数 ★★★
# 生存服特点：实体多、区块加载频繁、需要长期稳定运行
ZGC_MAX_PAUSE="100"      # 更小的暂停时间，提高响应性
ZGC_ALLOC_SPIKE="5.0"    # 更高的分配容忍度，避免突发GC
ZGC_COLLECTION_INTERVAL="30"  # 更频繁的收集，防止内存积累

# 系统资源限制
MAX_OPEN_FILES=65535     # 最大文件打开数
NICE_LEVEL="-5"          # 进程优先级
LOCK_FILE="./.server.lock"  # 锁文件路径

# 重启策略
NORMAL_RESTART_DELAY=20   # 正常退出后等待(秒)
CRASH_RESTART_DELAY=120   # 崩溃后等待(秒) - 给系统恢复时间

# 日志配置
LOG_DIR="./logs"
PERF_DIR="./monitor"
GC_LOG_ROTATION=10       # GC日志保留数量
GC_LOG_SIZE="50M"        # 单个GC日志大小

# ========== 初始化检查 ==========
echo "[初始化] 环境检查..."

# 1. 锁文件检查（防止多开）
exec 200>"${LOCK_FILE}"
if ! flock -n 200; then
    echo "[错误] 另一个服务端实例正在运行，或锁文件未释放。"
    echo "[提示] 如果确定没有其他实例，请删除: ${LOCK_FILE}"
    exit 1
fi

# 清理函数
cleanup() {
    echo "[清理] 释放资源..."
    flock -u 200
    rm -f "${LOCK_FILE}"
    
    # 停止性能监控进程
    if [ -n "${MONITOR_PID}" ] && kill -0 "${MONITOR_PID}" 2>/dev/null; then
        kill "${MONITOR_PID}" 2>/dev/null
        wait "${MONITOR_PID}" 2>/dev/null
    fi
    
    echo "[清理] 完成"
    exit 0
}

# 注册信号处理
trap cleanup EXIT INT TERM

# 2. 检查Java环境
if [ ! -x "${JAVA_BIN}" ]; then
    echo "[错误] Java可执行文件不存在或没有执行权限: ${JAVA_BIN}"
    exit 1
fi

# 3. 检查核心文件
if [ ! -f "${JAR_FILE}" ]; then
    echo "[错误] 服务器核心文件不存在: ${JAR_FILE}"
    exit 1
fi

# 4. 创建必要的目录
mkdir -p "${LOG_DIR}" "${PERF_DIR}" "world" "plugins" "logs/crash-reports"

# 5. 显示Java版本
JAVA_VERSION=$("${JAVA_BIN}" -version 2>&1 | head -n 1 | cut -d'"' -f2)
echo "[Java] 版本: ${JAVA_VERSION}"

# ========== 系统资源检查 ==========
echo "[系统] 检查系统资源..."

# 检测CPU核心数
CPU_CORES=$(nproc)
echo "[CPU] 核心数: ${CPU_CORES}"

# 自动调整GC线程数（基于CPU核心数）
calculate_gc_threads() {
    local cores=${CPU_CORES}
    
    if [ ${cores} -ge 16 ]; then
        CONC_GC_THREADS=$((cores / 4))
        PARALLEL_GC_THREADS=$((cores * 3 / 4))
    elif [ ${cores} -ge 8 ]; then
        CONC_GC_THREADS=$((cores / 2))
        PARALLEL_GC_THREADS=${cores}
    elif [ ${cores} -ge 4 ]; then
        CONC_GC_THREADS=${cores}
        PARALLEL_GC_THREADS=${cores}
    else
        CONC_GC_THREADS=2
        PARALLEL_GC_THREADS=4
    fi
    
    # 确保最小值
    CONC_GC_THREADS=$((CONC_GC_THREADS < 2 ? 2 : CONC_GC_THREADS))
    PARALLEL_GC_THREADS=$((PARALLEL_GC_THREADS < 4 ? 4 : PARALLEL_GC_THREADS))
}

calculate_gc_threads
echo "[GC] 线程配置 - 并发: ${CONC_GC_THREADS}, 并行: ${PARALLEL_GC_THREADS}"

# 检查容器内存限制（Docker环境）
check_container_memory() {
    if [ -f "/sys/fs/cgroup/memory/memory.limit_in_bytes" ]; then
        local container_limit=$(cat /sys/fs/cgroup/memory/memory.limit_in_bytes)
        local host_memory=$(free -b | awk '/^Mem:/{print $2}')
        
        # 如果容器限制小于主机内存，说明设置了内存限制
        if [ "${container_limit}" -lt "${host_memory}" ]; then
            local limit_gb=$((container_limit / 1024 / 1024 / 1024))
            echo "[容器] 检测到内存限制: ${limit_gb}GB"
            
            # 自动调整XMX为容器内存的85%
            local auto_xmx_gb=$((limit_gb * 85 / 100))
            if [ ${auto_xmx_gb} -ge 4 ]; then
                XMX="${auto_xmx_gb}G"
                XMS="$((auto_xmx_gb * 80 / 100))G"
                SOFT_MAX_HEAP="$((auto_xmx_gb * 85 / 100))G"
                echo "[容器] 自动调整内存: Xms=${XMS}, Xmx=${XMX}, SoftMaxHeap=${SOFT_MAX_HEAP}"
            fi
        fi
    fi
}

check_container_memory

# 内存可用性检查
check_memory_availability() {
    echo "[内存] 检查可用内存..."
    
    local total_mem_kb=$(grep MemTotal /proc/meminfo | awk '{print $2}')
    local available_mem_kb=$(grep MemAvailable /proc/meminfo | awk '{print $2}')
    
    local total_mem_gb=$((total_mem_kb / 1024 / 1024))
    local available_mem_gb=$((available_mem_kb / 1024 / 1024))
    
    echo "[内存] 总量: ${total_mem_gb}GB, 可用: ${available_mem_gb}GB"
    
    # 计算需要的JVM内存（堆内存 + 堆外内存）
    local xmx_gb=$(echo "${XMX%G}")
    local estimated_total_mem=$((xmx_gb + xmx_gb / 4))  # 堆内存 + 25%堆外内存
    
    if [ ${available_mem_gb} -lt ${estimated_total_mem} ]; then
        echo "[警告] 可用内存可能不足！"
        echo "[警告] 配置堆内存: ${xmx_gb}GB，预计总需求: ${estimated_total_mem}GB"
        echo "[警告] 系统可用内存: ${available_mem_gb}GB"
        
        # 非交互模式下自动继续
        if [ -t 0 ]; then
            read -t 30 -p "是否继续启动？(y/N): " user_choice
            if [[ ! "${user_choice}" =~ ^[Yy]$ ]]; then
                echo "[退出] 用户取消启动"
                exit 1
            fi
        else
            echo "[警告] 非交互模式，继续启动..."
        fi
    fi
    
    # 检查Swap使用
    local swap_used=$(free -h | grep Swap | awk '{print $3}')
    if [[ "${swap_used}" != "0B" ]] && [[ "${swap_used}" != "0" ]]; then
        echo "[警告] 系统正在使用交换空间: ${swap_used}"
        echo "[提示] 物理内存充足时应避免使用Swap"
    fi
}

check_memory_availability

# 设置系统资源限制
echo "[系统] 设置资源限制..."
ulimit -n ${MAX_OPEN_FILES} >/dev/null 2>&1 || echo "[警告] 设置文件打开数失败"

# 设置进程优先级
if command -v nice >/dev/null 2>&1; then
    NICE_CMD="nice -n ${NICE_LEVEL}"
else
    NICE_CMD=""
    echo "[信息] nice命令不可用"
fi

# ========== JVM参数构建 ==========
echo "[JVM] 构建启动参数..."

# ★★★ 生存服专用JVM参数 ★★★
# 重点：稳定性、区块管理、实体控制
JVM_OPTS="
    # 内存配置
    -Xms${XMS}
    -Xmx${XMX}
    
    # ZGC配置 - 生存服优化
    -XX:+UnlockExperimentalVMOptions
    -XX:+UseZGC
    -XX:+ZGenerational
    -XX:MaxGCPauseMillis=${ZGC_MAX_PAUSE}
    -XX:ConcGCThreads=${CONC_GC_THREADS}
    -XX:ParallelGCThreads=${PARALLEL_GC_THREADS}
    -XX:SoftMaxHeapSize=${SOFT_MAX_HEAP}
    -XX:ZAllocationSpikeTolerance=${ZGC_ALLOC_SPIKE}
    -XX:ZCollectionInterval=${ZGC_COLLECTION_INTERVAL}
    -XX:ZUncommitDelay=600
    -XX:+UseDynamicNumberOfGCThreads
    
    # Docker容器支持
    -XX:+UseContainerSupport
    -XX:MaxRAMPercentage=85.0
    -XX:InitialRAMPercentage=80.0
    
    # 内存和性能优化
    -XX:ReservedCodeCacheSize=512M
    -XX:InitialCodeCacheSize=256M
    -XX:SoftRefLRUPolicyMSPerMB=50
    -XX:+DisableExplicitGC
    -XX:+PerfDisableSharedMem
    -XX:+UseFastUnorderedTimeStamps
    -XX:+UseTransparentHugePages
    -XX:+AlwaysPreTouch
    -XX:AllocatePrefetchStyle=3
    -XX:+UseCompressedOops
    -XX:+UseCompressedClassPointers
    -XX:ObjectAlignmentInBytes=16
	
    # 活动服专用（高并发、快速响应）
	-Dpaper.playerconnection.keepalive=30  # 更短的keepalive
	-Dpaper.max-players=80                 # 设置更高上限
	-Dpaper.login-throughput=20            # 提高登录吞吐量
	-Dpaper.max-entity-collisions=1        # 最小化碰撞计算
	-Dpaper.disable-move-event=true        # 减少移动事件
	-Dpaper.max-chunk-radius=5             # 减少可视区块
	-Dpaper.async-chunks=true              # 异步区块加载
	
    # 网络优化
    -Djava.net.preferIPv4Stack=true
    -Djdk.nio.maxCachedBufferSize=262144
    -Dsun.net.client.defaultConnectTimeout=10000
    -Dsun.net.client.defaultReadTimeout=30000
    
    # 日志配置
    -Xlog:gc*,gc+phases*,gc+heap*,safepoint*:file=${LOG_DIR}/gc-%t.log:time,level,tags:filecount=${GC_LOG_ROTATION},filesize=${GC_LOG_SIZE}
    -Xlog:async
    -XX:+LogAsync
    -XX:ErrorFile=${LOG_DIR}/hs_err_pid%p.log
    -XX:+HeapDumpOnOutOfMemoryError
    -XX:HeapDumpPath=${LOG_DIR}/
    -XX:OnOutOfMemoryError=/bin/bash -c 'echo \"[紧急] JVM内存溢出！\" > ${LOG_DIR}/oom_alert.log'
    
    # 系统设置
    -Dfile.encoding=UTF-8
    -Duser.country=CN
    -Duser.language=zh
    -Duser.timezone=Asia/Shanghai
    -Djava.awt.headless=true
    -Dterminal.ansi=true
    -Dlog4j2.formatMsgNoLookups=true
"

# 压缩JVM参数（移除换行和多余空格）
JVM_OPTS=$(echo "${JVM_OPTS}" | sed ':a;N;$!ba;s/\n/ /g' | sed 's/  */ /g')

# ========== 性能监控函数 ==========
start_performance_monitor() {
    local server_pid=$1
    
    # 监控脚本运行在后台
    (
        echo "[监控] 性能监控进程启动 (PID: $$)"
        
        while kill -0 "${server_pid}" 2>/dev/null; do
            local timestamp=$(date "+%Y-%m-%d %H:%M:%S")
            
            # 获取进程内存信息
            local mem_info=$(ps -p "${server_pid}" -o rss,vsz,pmem --no-headers 2>/dev/null || echo "0 0 0")
            local rss_kb=$(echo "${mem_info}" | awk '{print $1}')
            local vsz_kb=$(echo "${mem_info}" | awk '{print $2}')
            local pmem=$(echo "${mem_info}" | awk '{print $3}')
            
            # 获取CPU使用率
            local cpu_info=$(top -bn1 -p "${server_pid}" | tail -1)
            local cpu_usage=$(echo "${cpu_info}" | awk '{printf "%.1f%%", $9}')
            
            # 获取系统内存
            local sys_mem=$(free -m | awk 'NR==2{printf "%.1f/%.1fGB", $3/1024, $2/1024}')
            local swap_used=$(free -m | awk 'NR==3{printf "%.1fGB", $3/1024}')
            
            # 记录到日志文件
            echo "${timestamp} | PID:${server_pid} | RSS:${rss_kb}KB | CPU:${cpu_usage} | 系统内存:${sys_mem} | 交换:${swap_used}" \
                >> "${PERF_DIR}/performance-$(date +%Y%m%d).log"
            
            # 每小时记录一次详细GC状态
            if [ "$(date +%M)" = "00" ]; then
                echo "=== 详细状态 $(date) ===" >> "${PERF_DIR}/status-$(date +%Y%m%d).log"
                "${JAVA_BIN}" -cp "${JAR_FILE}" -XX:+PrintFlagsFinal 2>/dev/null | grep -i heap >> "${PERF_DIR}/status-$(date +%Y%m%d).log"
                echo "" >> "${PERF_DIR}/status-$(date +%Y%m%d).log"
            fi
            
            # 监控间隔：5分钟
            sleep 300
        done
        
        echo "[监控] 服务器进程已停止，监控结束"
    ) &
    
    echo $!  # 返回监控进程的PID
}

# ========== 显示配置摘要 ==========
echo "╔══════════════════════════════════════════════════════╗"
echo "║                   生存服配置摘要                      ║"
echo "╠══════════════════════════════════════════════════════╣"
echo "║ 服务器名称: ${SERVER_NAME}"
echo "║ Java版本: ${JAVA_VERSION}"
echo "║"
echo "║ 内存配置:"
echo "║   初始堆(Xms): ${XMS}"
echo "║   最大堆(Xmx): ${XMX}"
echo "║   软最大堆: ${SOFT_MAX_HEAP}"
echo "║"
echo "║ GC配置:"
echo "║   GC算法: ZGC (分代式)"
echo "║   最大暂停: ${ZGC_MAX_PAUSE}ms"
echo "║   并发线程: ${CONC_GC_THREADS}"
echo "║   并行线程: ${PARALLEL_GC_THREADS}"
echo "║   收集间隔: ${ZGC_COLLECTION_INTERVAL}s"
echo "║"
echo "║ 系统资源:"
echo "║   CPU核心: ${CPU_CORES}"
echo "║   文件限制: ${MAX_OPEN_FILES}"
echo "║   优先级: nice=${NICE_LEVEL}"
echo "╚══════════════════════════════════════════════════════╝"
echo ""

# ========== 主启动循环 ==========
RESTART_COUNT=0
MAX_RESTARTS=20
START_TIME=$(date +%s)

echo "[启动] 进入主循环，按 Ctrl+C 安全停止服务器"
echo ""

while true; do
    RESTART_COUNT=$((RESTART_COUNT + 1))
    CURRENT_TIME=$(date "+%Y-%m-%d %H:%M:%S")
    UPTIME_SECONDS=$(( $(date +%s) - START_TIME ))
    UPTIME_READABLE=$(printf "%dd %dh %dm %ds" $((UPTIME_SECONDS/86400)) $((UPTIME_SECONDS%86400/3600)) $((UPTIME_SECONDS%3600/60)) $((UPTIME_SECONDS%60)))
    
    echo "╔══════════════════════════════════════════════════════╗"
    echo "║ 启动次数: #${RESTART_COUNT}                                ║"
    echo "║ 时间: ${CURRENT_TIME}                          ║"
    echo "║ 运行时间: ${UPTIME_READABLE}                          ║"
    echo "║ 服务器: ${SERVER_NAME}                   ║"
    echo "╚══════════════════════════════════════════════════════╝"
    
    # 检查重启次数限制
    if [ ${RESTART_COUNT} -gt ${MAX_RESTARTS} ]; then
        echo "[错误] 达到最大重启次数限制 (${MAX_RESTARTS})"
        echo "[错误] 服务器可能存在问题，请检查日志并手动修复"
        exit 1
    fi
    
    # 设置终端标题
    echo -ne "\033]0;${SERVER_NAME} (#${RESTART_COUNT})\007"
    
    # 构建最终启动命令
    CMD="${NICE_CMD} ${JAVA_BIN} ${JVM_OPTS} -jar \"${JAR_FILE}\" --nogui"
    
    # 记录启动日志
    {
        echo "=== 服务器启动 $(date) ==="
        echo "启动次数: ${RESTART_COUNT}"
        echo "运行时间: ${UPTIME_READABLE}"
        echo "命令: ${CMD}"
        echo "系统内存: $(free -h | awk '/^Mem:/{print $3"/"$2}')"
        echo "交换空间: $(free -h | awk '/^Swap:/{print $3"/"$2}')"
        echo ""
    } >> "${LOG_DIR}/startup.log"
    
    echo "[进程] 启动服务器..."
    
    # 启动服务器进程
    eval ${CMD} &
    SERVER_PID=$!
    
    echo "[进程] 服务器PID: ${SERVER_PID}"
    
    # 启动性能监控
    MONITOR_PID=$(start_performance_monitor ${SERVER_PID})
    echo "[监控] 监控进程PID: ${MONITOR_PID}"
    
    # 等待服务器进程结束
    wait ${SERVER_PID}
    EXIT_CODE=$?
    
    # 停止监控进程
    if [ -n "${MONITOR_PID}" ] && kill -0 "${MONITOR_PID}" 2>/dev/null; then
        kill "${MONITOR_PID}" 2>/dev/null
        wait "${MONITOR_PID}" 2>/dev/null
        echo "[监控] 监控进程已停止"
    fi
    
    echo ""
    echo "╔══════════════════════════════════════════════════════╗"
    echo "║                    服务器退出                         ║"
    echo "╠══════════════════════════════════════════════════════╣"
    echo "║ 退出码: ${EXIT_CODE}"
    
    # 分析退出原因
    case ${EXIT_CODE} in
        0)
            echo "║ 原因: 正常关闭 (stop命令)"
            WAIT_TIME=${NORMAL_RESTART_DELAY}
            ;;
        130)
            echo "║ 原因: 用户中断 (Ctrl+C)"
            WAIT_TIME=${NORMAL_RESTART_DELAY}
            ;;
        137)
            echo "║ 原因: 被SIGKILL终止 (kill -9)"
            echo "║ 建议: 检查是否内存不足被OOM Killer终止"
            WAIT_TIME=${CRASH_RESTART_DELAY}
            ;;
        143)
            echo "║ 原因: 被SIGTERM终止"
            WAIT_TIME=${NORMAL_RESTART_DELAY}
            ;;
        1)
            echo "║ 原因: 一般错误"
            echo "║ 建议: 检查server.log查看具体错误"
            WAIT_TIME=${CRASH_RESTART_DELAY}
            ;;
        *)
            echo "║ 原因: 未知错误 (代码: ${EXIT_CODE})"
            echo "║ 建议: 查看server.log和hs_err_pid*.log"
            WAIT_TIME=${CRASH_RESTART_DELAY}
            ;;
    esac
    
    # 检查是否有崩溃报告
    if find . -name "hs_err_pid*.log" -mmin -5 2>/dev/null | grep -q .; then
        echo "║ 警告: 发现JVM崩溃报告！"
        echo "║ 建议: 检查hs_err_pid*.log文件"
    fi
    
    echo "║ 等待: ${WAIT_TIME}秒后重启"
    echo "╚══════════════════════════════════════════════════════╝"
    
    # 生成重启报告
    {
        echo "=== 重启报告 $(date) ==="
        echo "退出码: ${EXIT_CODE}"
        echo "运行时长: ${UPTIME_READABLE}"
        echo "重启次数: ${RESTART_COUNT}"
        echo "系统内存: $(free -h | awk '/^Mem:/{print $3"/"$2}')"
        echo "下次启动: $(date -d "+${WAIT_TIME} seconds" "+%H:%M:%S")"
        echo ""
    } >> "${PERF_DIR}/restart-report.log"
    
    # 重启倒计时
    for ((i=WAIT_TIME; i>0; i--)); do
        printf "[等待] %d秒后重启 (本次运行: %s) | 按 Ctrl+C 永久停止\r" ${i} "${UPTIME_READABLE}"
        sleep 1
    done
    
    echo -e "\n"
    
    # 如果是长时间运行后崩溃，清理内存缓存
    if [ ${UPTIME_SECONDS} -gt 3600 ] && [ ${EXIT_CODE} -ne 0 ] && [ ${EXIT_CODE} -ne 130 ]; then
        echo "[清理] 长时间运行后崩溃，释放系统缓存..."
        sync
        echo 1 > /proc/sys/vm/drop_caches 2>/dev/null || true
        sleep 2
    fi
    
    # 重置运行时间计数器
    START_TIME=$(date +%s)
done